## Intention: re-collect relevant scripts for paper on B1_insensitivity, as outlined in Word document
#  "B1findingsRetrospective"
#  Initiated 2024-12-05


## 2024-12-05 Recap 1D simulations
#  (taken from B1_1D_simulation_script.jl)

function sawtooth(segs, center, spread, useLog=true)
    saw = zeros(segs)
    qs = segs÷4
    saw[1:qs]      = spread .* collect(range(start=0, stop=-1, length=qs))
    saw[qs+1:3*qs] = spread .* collect(range(start=-1, stop=1, length=2*qs))
    saw[3*qs+1:4*qs]=spread .* collect(range(start=1, stop=0, length=qs))
    if useLog
        saw = center .* exp.(saw)
    else
        saw = center .* max.((saw.+1.0),0.0)
    end
    return saw
end

include("../startup.jl")
#include("../BLAKJac/setup.jl")
include("setup.jl")
include("WrecSimulRun.jl")
include("../numerical_phantom/load_data_phantom.jl");
include("../numerical_phantom/RF_Shapes.jl");

resource = has_cuda_gpu() ? CUDALibs() : CPU1()
#recon_options = MRSTATToolbox.Reconstruction.load_default_recon_options()
#recon_options = load_default_recon_options(recon_options);
recon_options = load_default_recon_options();

recon_options["recon_folder"] = "tmp";
recon_options["recon_subfolder"] = "tmp";
recon_options["numphantom"] = true;
recon_options["numphantom_rf_shape"] = "from_file" 

nky = 224
recon_options["objectSegs"] = nky # 14
recon_options["maxRho"]   = 1.0
recon_options["simulationT1center"]  = 0.7 # 1.3
recon_options["simulationT2center"]  = 0.07 # 0.2
recon_options["simulationB1center"]  = 1.0
crit_k                                =  0.0 # 12.0 # 0.0 # 12.0
recon_options["simulationVariable"] = "B1" # "TR/TD" # "measured from phantom"
recon_options["simulationSpread"] = 0.3 # 0.0 # 0.8 # 1.6 # 0.4 # 0.8 # used 0.8 for T1 and T2, 1.3 for δ # 0.3 for B1
recon_options["RhoVariation"]   = 0.0 

recon_options["numphantom_type"] = "line" # "line", "brainweb", "checkerboard", "shepp_logan", "tubes", "flat"
recon_options["numphantom_size"] = (1,nky) # (224,224)
recon_options["numphantom_sequence"] = "Spoiled" # "Spoiled", "Balanced"
recon_options["numphantom_trajectory"] = "Cartesian" # "Cartesian", "Radial"
recon_options["numphantom_noise"] = false
recon_options["simulation_parameters"] = T₁T₂B₁ρˣρʸ
recon_options["reconstruction_parameters"] = T₁T₂ρˣρʸ

recon_options["slice"] = 1;
recon_options["coils"] = 1; # should be a range
recon_options["maxstate"] = 64; 
recon_options["lsqr_its"] = 10;
recon_options["trf_max_iter_steihaug"] = 30;
recon_options["trf_max_iter"] = 20;
recon_options["slice_discretization"] = 1
recon_options["slice_profile_correction"] = "shinnar_leroux" # small_tip_angle or shinnar_leroux
recon_options["slice_thickness_multiplier"] = 1 # compute slice profiles from 0 to multiplier * nominal slice thickness

recon_options["scaling_factor"] = 1.0;         

#adpt(x) = MRSTAT.Reconstruction.adapt_to(resource, x)
noplot(x; figtitle="") = println("no plotting")

rng = MersenneTwister(2)

nrSegments = recon_options["objectSegs"]
spread = recon_options["simulationSpread"]
rhoVar = recon_options["RhoVariation"]
segsT1 = recon_options["simulationT1center"] .* ones(nrSegments)
segsT2 = recon_options["simulationT2center"] .* ones(nrSegments)
segsB1 = recon_options["simulationB1center"] .* ones(nrSegments)
if recon_options["simulationVariable"]=="T1"
    segsT1 = sawtooth(nrSegments, recon_options["simulationT1center"], spread)
elseif recon_options["simulationVariable"]=="T2"
    segsT2 = sawtooth(nrSegments, recon_options["simulationT2center"], spread)
elseif recon_options["simulationVariable"]=="B1"
    segsB1  = sawtooth(nrSegments, recon_options["simulationB1center"], spread, false)
elseif recon_options["simulationVariable"]=="measured from phantom";
    ; # no overwrites
else @assert false
end

segsRho = [recon_options["maxRho"]*exp(im*2*pi*crit_k *i/nrSegments) for i in 1:nrSegments]
segsMask = ones(nrSegments)
segsRho .*= segsMask
(xl,yl) = recon_options["numphantom_size"]
repfac = Int64(round(yl/nrSegments))

simRho = repeat(segsRho, inner=repfac)
simT1  = repeat(segsT1,  inner=repfac)
simT2  = repeat(segsT2,  inner=repfac)
simB1  = repeat(segsB1,  inner=repfac)
simMask =repeat(segsMask,inner=repfac)
B₁map = ones(yl)


# description         = ["noise,no P",    "B1opt,no P",    "noise, phase",     "B1opt, phase"]  
# cases               = ["20240702V(5)",  "20240703W(5)",  "20240701S(5)",    "20240703X(3)"]
# nR                  = [1,                1,               1,                  1]
description         = ["noise,no P",    "B1opt,no P",    "noise, phase",     "B1opt, phase"]  
cases               = ["20240702V"   ,  "20240703W"   ,  "20240701S",       "20240703X"]
nR                  = [10,              10,              10,                 10] 
# for test
# description         = ["noise,no P"]  
# cases               = ["20240622D"] 
# nR                  = [1]

sweeps              = 6
startstate          = -1
mbiasT1 = zeros(length(cases),nrSegments)
mbiasT2 = zeros(length(cases),nrSegments)
mT2     = zeros(length(cases),nrSegments)

lines_color_cycle = [p["color"] for p in plt.rcParams["axes.prop_cycle"]]
(figd,axd)=subplots(1,figsize=(18,18))

for (caseIndex,case) in enumerate(cases)
    for r in 1:nR[caseIndex]
        recon_options["rfFile"]  = nR[caseIndex]==1 ? case : case*"($r)"
        recon_options["nTR"]      = nky*sweeps
        recon_options["startstate"] = startstate

        sequence, coordinates, coilmaps, trajectory, mask, phantom = load_data_phantom(recon_options);
        # @show sequence.sliceprofiles 
        ρ = complex.(simRho)
        ρ = eltype((gpu(f32(sequence))).RF_train).(ρ)
        parameters = collect(vec(phantom));

        #parameters_with_B1 = [T₁T₂B₁xy(simT1[i],simT2[i], simB1[i], coordinates[i][1], coordinates[i][2]) for i in eachindex(parameters)]
        parameters_with_B1 = [T₁T₂B₁(simT1[i],simT2[i], simB1[i]) for i in eachindex(parameters)]
        recon_options["simulation_parameters"] = T₁T₂B₁ρˣρʸ

        echos = simulate_magnetization(resource, gpu(f32((sequence))), gpu(f32((parameters_with_B1))))
        coilmaps_mat = reshape(only.(coilmaps), length(coilmaps),1)

        trajectory_a = gpu(f32(trajectory))
        parameters_with_B1_a = gpu(f32(StructVector(parameters_with_B1)))
        phase_encoding!(echos, trajectory_a, parameters_with_B1_a)

        raw_data = MRSTAT.TimeDomainOperators.Mv(CUDALibs(), echos, parameters_with_B1_a, trajectory_a, 
                                                            gpu(f32(coilmaps_mat)), gpu(f32(StructVector(coordinates))), gpu(f32(simRho)))
        rrr1 = raw_data[:,:,1]
        rrr2 = vec(rrr1)
        rrr3 = collect(rrr2)
        raw_data = SVector{1}.(rrr3)
        #raw_data = collect(vec(only(raw_data)));
        #raw_data = SVector{1}.(raw_data)

        recon_options["simulation_parameters"] = T₁T₂ρˣρʸ
        output = mrstat_recon(sequence, trajectory, raw_data, mask, 
                                coordinates, coilmaps, B₁map, recon_options, resource, noplot, recon_options["recon_subfolder"])
        recon_res = output.qmaps[end]

        rT1 = reshape(recon_res.T₁, repfac, nrSegments)
        rT2 = reshape(recon_res.T₂, repfac, nrSegments)
        sT1 = reshape(simT1, repfac, nrSegments)
        sT2 = reshape(simT2, repfac, nrSegments)
        sB1 = reshape(simB1, repfac, nrSegments)

        mbiasT1[caseIndex,:] = mean(sT1.-rT1, dims=1) |> vec
        mbiasT2[caseIndex,:] = mean(sT2.-rT2, dims=1) |> vec
        mT2[caseIndex,:]     = mean(  sT2,    dims=1) |> vec

        sVar = copy(sT1)
        if recon_options["simulationVariable"]=="T1"; sVar = sT1;
        elseif recon_options["simulationVariable"]=="T2"; sVar = sT2;
        elseif recon_options["simulationVariable"]=="B1"; sVar = sB1;
        elseif recon_options["simulationVariable"]=="measured from phantom"
            from_measured =  measuredS[caseIndex]*sB1[1]/recon_options["TR"]*(sT2[1]*(sT2[1]+0.12))
            sVar .= from_measured;
        else @assert false
        end

        centerRange=nky÷2-50 : nky÷2+50
        color = lines_color_cycle[caseIndex]
        #data = rT2[centerRange] .- sT2[centerRange]   
        data = rT1[centerRange] .- sT1[centerRange]   
        label = description[caseIndex]
        @show label, r, data[1]   
        # If r equals 1, add a label to the plot
        if r == 1
            axd.plot(sVar[centerRange], data, color=color, label=label)
        else
            axd.plot(sVar[centerRange], data, color=color)
        end
        axd.text(sVar[centerRange][1], data[1], string(r), color=color)

    end
end
axd.set_xlabel("value of $(recon_options["simulationVariable"])")
axd.set_ylabel("bias on T1 [s]")
axd.legend()
txtt1 = "T1=$(recon_options["simulationT1center"])s, "
txtt2 = "T2=$(recon_options["simulationT2center"])s, "
txtB1 = "B1=$(recon_options["simulationB1center"])"
if recon_options["simulationVariable"]=="T1"; txtt1="T1=variable, ";
elseif recon_options["simulationVariable"]=="T2"; txtt2="T2=variable, ";
elseif recon_options["simulationVariable"]=="B1"; txtB1="B1=variable";
elseif recon_options["simulationVariable"]=="measured from phantom"
    ; # no overwrite of texts
else @assert false
end
axd.text(0.2,0.9,txtt1*txtt2*txtB1, transform=axd.transAxes)

if recon_options["simulationVariable"]=="measured from phantom"
    axd.plot([0.0,0.02],[0.0,0.02],color="black")
end







