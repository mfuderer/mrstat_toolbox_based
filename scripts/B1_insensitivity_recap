## Intention: re-collect relevant scripts for paper on B1_insensitivity, as outlined in Word document
#  "B1findingsRetrospective"
#  Initiated 2024-12-05


## 2024-12-05 Recap 1D simulations
#  (taken from B1_1D_simulation_script.jl)

function sawtooth(segs, center, spread, useLog=true)
    saw = zeros(segs)
    qs = segs÷4
    saw[1:qs]      = spread .* collect(range(start=0, stop=-1, length=qs))
    saw[qs+1:3*qs] = spread .* collect(range(start=-1, stop=1, length=2*qs))
    saw[3*qs+1:4*qs]=spread .* collect(range(start=1, stop=0, length=qs))
    if useLog
        saw = center .* exp.(saw)
    else
        saw = center .* max.((saw.+1.0),0.0)
    end
    return saw
end

include("../startup.jl")
#include("../BLAKJac/setup.jl")
include("setup.jl")
include("WrecSimulRun.jl")
include("../numerical_phantom/load_data_phantom.jl");
include("../numerical_phantom/RF_Shapes.jl");

resource = has_cuda_gpu() ? CUDALibs() : CPU1()
#recon_options = MRSTATToolbox.Reconstruction.load_default_recon_options()
#recon_options = load_default_recon_options(recon_options);
recon_options = load_default_recon_options();

recon_options["recon_folder"] = "tmp";
recon_options["recon_subfolder"] = "tmp";
recon_options["numphantom"] = true;
recon_options["numphantom_rf_shape"] = "from_file" 

nky = 224
recon_options["objectSegs"] = nky # 14
recon_options["maxRho"]   = 1.0
recon_options["simulationT1center"]  = 0.7 # 1.3
recon_options["simulationT2center"]  = 0.07 # 0.2
recon_options["simulationB1center"]  = 1.0
crit_k                                =  0.0 # 12.0 # 0.0 # 12.0
recon_options["simulationVariable"] = "B1" # "TR/TD" # "measured from phantom"
recon_options["simulationSpread"] = 0.3 # 0.0 # 0.8 # 1.6 # 0.4 # 0.8 # used 0.8 for T1 and T2, 1.3 for δ # 0.3 for B1
recon_options["RhoVariation"]   = 0.0 

recon_options["numphantom_type"] = "line" # "line", "brainweb", "checkerboard", "shepp_logan", "tubes", "flat"
recon_options["numphantom_size"] = (1,nky) # (224,224)
recon_options["numphantom_sequence"] = "Spoiled" # "Spoiled", "Balanced"
recon_options["numphantom_trajectory"] = "Cartesian" # "Cartesian", "Radial"
recon_options["numphantom_noise"] = false
recon_options["simulation_parameters"] = T₁T₂B₁ρˣρʸ
recon_options["reconstruction_parameters"] = T₁T₂ρˣρʸ

recon_options["slice"] = 1;
recon_options["coils"] = 1; # should be a range
recon_options["maxstate"] = 64; 
recon_options["lsqr_its"] = 10;
recon_options["trf_max_iter_steihaug"] = 30;
recon_options["trf_max_iter"] = 20;
recon_options["slice_discretization"] = 1
recon_options["slice_profile_correction"] = "shinnar_leroux" # small_tip_angle or shinnar_leroux
recon_options["slice_thickness_multiplier"] = 1 # compute slice profiles from 0 to multiplier * nominal slice thickness

recon_options["scaling_factor"] = 1.0;         

#adpt(x) = MRSTAT.Reconstruction.adapt_to(resource, x)
noplot(x; figtitle="") = println("no plotting")

rng = MersenneTwister(2)

nrSegments = recon_options["objectSegs"]
spread = recon_options["simulationSpread"]
rhoVar = recon_options["RhoVariation"]
segsT1 = recon_options["simulationT1center"] .* ones(nrSegments)
segsT2 = recon_options["simulationT2center"] .* ones(nrSegments)
segsB1 = recon_options["simulationB1center"] .* ones(nrSegments)
if recon_options["simulationVariable"]=="T1"
    segsT1 = sawtooth(nrSegments, recon_options["simulationT1center"], spread)
elseif recon_options["simulationVariable"]=="T2"
    segsT2 = sawtooth(nrSegments, recon_options["simulationT2center"], spread)
elseif recon_options["simulationVariable"]=="B1"
    segsB1  = sawtooth(nrSegments, recon_options["simulationB1center"], spread, false)
elseif recon_options["simulationVariable"]=="measured from phantom";
    ; # no overwrites
else @assert false
end

segsRho = [recon_options["maxRho"]*exp(im*2*pi*crit_k *i/nrSegments) for i in 1:nrSegments]
segsMask = ones(nrSegments)
segsRho .*= segsMask
(xl,yl) = recon_options["numphantom_size"]
repfac = Int64(round(yl/nrSegments))

simRho = repeat(segsRho, inner=repfac)
simT1  = repeat(segsT1,  inner=repfac)
simT2  = repeat(segsT2,  inner=repfac)
simB1  = repeat(segsB1,  inner=repfac)
simMask =repeat(segsMask,inner=repfac)
B₁map = ones(yl)


# description         = ["noise,no P",    "B1opt,no P",    "noise, phase",     "B1opt, phase"]  
# cases               = ["20240702V(5)",  "20240703W(5)",  "20240701S(5)",    "20240703X(3)"]
# nR                  = [1,                1,               1,                  1]
description         = ["noise,no P",    "B1opt,no P",    "noise, phase",     "B1opt, phase"]  
cases               = ["20240702V"   ,  "20240703W"   ,  "20240701S",       "20240703X"]
nR                  = [10,              10,              10,                 10] 
# for test
# description         = ["noise,no P"]  
# cases               = ["20240622D"] 
# nR                  = [1]

sweeps              = 6
startstate          = -1
mbiasT1 = zeros(length(cases),nrSegments)
mbiasT2 = zeros(length(cases),nrSegments)
mT2     = zeros(length(cases),nrSegments)

lines_color_cycle = [p["color"] for p in plt.rcParams["axes.prop_cycle"]]
(figd,axd)=subplots(1,figsize=(18,18))

for (caseIndex,case) in enumerate(cases)
    for r in 1:nR[caseIndex]
        recon_options["rfFile"]  = nR[caseIndex]==1 ? case : case*"($r)"
        recon_options["nTR"]      = nky*sweeps
        recon_options["startstate"] = startstate

        sequence, coordinates, coilmaps, trajectory, mask, phantom = load_data_phantom(recon_options);
        # @show sequence.sliceprofiles 
        ρ = complex.(simRho)
        ρ = eltype((gpu(f32(sequence))).RF_train).(ρ)
        parameters = collect(vec(phantom));

        #parameters_with_B1 = [T₁T₂B₁xy(simT1[i],simT2[i], simB1[i], coordinates[i][1], coordinates[i][2]) for i in eachindex(parameters)]
        parameters_with_B1 = [T₁T₂B₁(simT1[i],simT2[i], simB1[i]) for i in eachindex(parameters)]
        recon_options["simulation_parameters"] = T₁T₂B₁ρˣρʸ

        echos = simulate_magnetization(resource, gpu(f32((sequence))), gpu(f32((parameters_with_B1))))
        coilmaps_mat = reshape(only.(coilmaps), length(coilmaps),1)

        trajectory_a = gpu(f32(trajectory))
        parameters_with_B1_a = gpu(f32(StructVector(parameters_with_B1)))
        phase_encoding!(echos, trajectory_a, parameters_with_B1_a)

        raw_data = MRSTAT.TimeDomainOperators.Mv(CUDALibs(), echos, parameters_with_B1_a, trajectory_a, 
                                                            gpu(f32(coilmaps_mat)), gpu(f32(StructVector(coordinates))), gpu(f32(simRho)))
        rrr1 = raw_data[:,:,1]
        rrr2 = vec(rrr1)
        rrr3 = collect(rrr2)
        raw_data = SVector{1}.(rrr3)
        #raw_data = collect(vec(only(raw_data)));
        #raw_data = SVector{1}.(raw_data)

        recon_options["simulation_parameters"] = T₁T₂ρˣρʸ
        output = mrstat_recon(sequence, trajectory, raw_data, mask, 
                                coordinates, coilmaps, B₁map, recon_options, resource, noplot, recon_options["recon_subfolder"])
        recon_res = output.qmaps[end]

        rT1 = reshape(recon_res.T₁, repfac, nrSegments)
        rT2 = reshape(recon_res.T₂, repfac, nrSegments)
        sT1 = reshape(simT1, repfac, nrSegments)
        sT2 = reshape(simT2, repfac, nrSegments)
        sB1 = reshape(simB1, repfac, nrSegments)

        mbiasT1[caseIndex,:] = mean(sT1.-rT1, dims=1) |> vec
        mbiasT2[caseIndex,:] = mean(sT2.-rT2, dims=1) |> vec
        mT2[caseIndex,:]     = mean(  sT2,    dims=1) |> vec

        sVar = copy(sT1)
        if recon_options["simulationVariable"]=="T1"; sVar = sT1;
        elseif recon_options["simulationVariable"]=="T2"; sVar = sT2;
        elseif recon_options["simulationVariable"]=="B1"; sVar = sB1;
        elseif recon_options["simulationVariable"]=="measured from phantom"
            from_measured =  measuredS[caseIndex]*sB1[1]/recon_options["TR"]*(sT2[1]*(sT2[1]+0.12))
            sVar .= from_measured;
        else @assert false
        end

        centerRange=nky÷2-50 : nky÷2+50
        color = lines_color_cycle[caseIndex]
        #data = rT2[centerRange] .- sT2[centerRange]   
        data = rT1[centerRange] .- sT1[centerRange]   
        label = description[caseIndex]
        @show label, r, data[1]   
        # If r equals 1, add a label to the plot
        if r == 1
            axd.plot(sVar[centerRange], data, color=color, label=label)
        else
            axd.plot(sVar[centerRange], data, color=color)
        end
        axd.text(sVar[centerRange][1], data[1], string(r), color=color)

    end
end
axd.set_xlabel("value of $(recon_options["simulationVariable"])")
axd.set_ylabel("bias on T1 [s]")
axd.legend()
txtt1 = "T1=$(recon_options["simulationT1center"])s, "
txtt2 = "T2=$(recon_options["simulationT2center"])s, "
txtB1 = "B1=$(recon_options["simulationB1center"])"
if recon_options["simulationVariable"]=="T1"; txtt1="T1=variable, ";
elseif recon_options["simulationVariable"]=="T2"; txtt2="T2=variable, ";
elseif recon_options["simulationVariable"]=="B1"; txtB1="B1=variable";
elseif recon_options["simulationVariable"]=="measured from phantom"
    ; # no overwrite of texts
else @assert false
end
axd.text(0.2,0.9,txtt1*txtt2*txtB1, transform=axd.transAxes)

if recon_options["simulationVariable"]=="measured from phantom"
    axd.plot([0.0,0.02],[0.0,0.02],color="black")
end




## 2024-12-13 As refactored by Oscar
function sawtooth(segs, center, spread, useLog=true)
    saw = zeros(segs)
    qs = segs÷4
    saw[1:qs]      = spread .* collect(range(start=0, stop=-1, length=qs))
    saw[qs+1:3*qs] = spread .* collect(range(start=-1, stop=1, length=2*qs))
    saw[3*qs+1:4*qs]=spread .* collect(range(start=1, stop=0, length=qs))
    if useLog
        saw = center .* exp.(saw)
    else
        saw = center .* max.((saw.+1.0),0.0)
    end
    return saw
end

include("../startup.jl")
#include("../BLAKJac/setup.jl")
include("setup.jl")
include("WrecSimulRun.jl")
include("../numerical_phantom/load_data_phantom.jl");
include("../numerical_phantom/RF_Shapes.jl");

resource = has_cuda_gpu() ? CUDALibs() : CPU1()
#recon_options = MRSTATToolbox.Reconstruction.load_default_recon_options()
#recon_options = load_default_recon_options(recon_options);
recon_options = load_default_recon_options();

recon_options["recon_folder"] = "tmp";
recon_options["recon_subfolder"] = "tmp";
recon_options["numphantom"] = true;
recon_options["numphantom_rf_shape"] = "from_file" 

nky = 224
recon_options["objectSegs"] = nky # 14
recon_options["maxRho"]   = 1.0
recon_options["simulationT1center"]  = 0.7 # 1.3
recon_options["simulationT2center"]  = 0.07 # 0.2
recon_options["simulationB1center"]  = 1.0
crit_k                                =  0.0 # 12.0 # 0.0 # 12.0
recon_options["simulationVariable"] = "B1" # "TR/TD" # "measured from phantom"
recon_options["simulationSpread"] = 0.3 # 0.0 # 0.8 # 1.6 # 0.4 # 0.8 # used 0.8 for T1 and T2, 1.3 for δ # 0.3 for B1
recon_options["RhoVariation"]   = 0.0 

recon_options["numphantom_type"] = "line" # "line", "brainweb", "checkerboard", "shepp_logan", "tubes", "flat"
recon_options["numphantom_size"] = (1,nky) # (224,224)
recon_options["numphantom_sequence"] = "Spoiled" # "Spoiled", "Balanced"
recon_options["numphantom_trajectory"] = "Cartesian" # "Cartesian", "Radial"
recon_options["numphantom_noise"] = false
recon_options["simulation_parameters"] = T₁T₂B₁ρˣρʸ
recon_options["reconstruction_parameters"] = T₁T₂ρˣρʸ

recon_options["slice"] = 1;
recon_options["coils"] = 1; # should be a range
recon_options["maxstate"] = 64; 
recon_options["lsqr_its"] = 10;
recon_options["trf_max_iter_steihaug"] = 30;
recon_options["trf_max_iter"] = 20;
recon_options["slice_discretization"] = 1
recon_options["slice_profile_correction"] = "shinnar_leroux" # small_tip_angle or shinnar_leroux
recon_options["slice_thickness_multiplier"] = 1 # compute slice profiles from 0 to multiplier * nominal slice thickness

recon_options["scaling_factor"] = 1.0;         

#adpt(x) = MRSTAT.Reconstruction.adapt_to(resource, x)
noplot(x; figtitle="") = println("no plotting")

rng = MersenneTwister(2)

nrSegments = recon_options["objectSegs"]
spread = recon_options["simulationSpread"]
rhoVar = recon_options["RhoVariation"]
segsT1 = recon_options["simulationT1center"] .* ones(nrSegments)
segsT2 = recon_options["simulationT2center"] .* ones(nrSegments)
segsB1 = recon_options["simulationB1center"] .* ones(nrSegments)
if recon_options["simulationVariable"]=="T1"
    segsT1 = sawtooth(nrSegments, recon_options["simulationT1center"], spread)
elseif recon_options["simulationVariable"]=="T2"
    segsT2 = sawtooth(nrSegments, recon_options["simulationT2center"], spread)
elseif recon_options["simulationVariable"]=="B1"
    segsB1  = sawtooth(nrSegments, recon_options["simulationB1center"], spread, false)
elseif recon_options["simulationVariable"]=="measured from phantom";
    ; # no overwrites
else @assert false
end

segsRho = [recon_options["maxRho"]*exp(im*2*pi*crit_k *i/nrSegments) for i in 1:nrSegments]
segsMask = ones(nrSegments)
segsRho .*= segsMask
(xl,yl) = recon_options["numphantom_size"]
repfac = Int64(round(yl/nrSegments))

simRho = repeat(segsRho, inner=repfac)
simT1  = repeat(segsT1,  inner=repfac)
simT2  = repeat(segsT2,  inner=repfac)
simB1  = repeat(segsB1,  inner=repfac)
simMask =repeat(segsMask,inner=repfac)
B₁map = ones(yl)


# description         = ["noise,no P",    "B1opt,no P",    "noise, phase",     "B1opt, phase"]  
# cases               = ["20240702V(5)",  "20240703W(5)",  "20240701S(5)",    "20240703X(3)"]
# nR                  = [1,                1,               1,                  1]
description         = ["noise,no P",    "B1opt,no P",    "noise, phase",     "B1opt, phase"]  
cases               = ["20240702V"   ,  "20240703W"   ,  "20240701S",       "20240703X"]
nR                  = [10,              10,              10,                 10] 
# for test
# description         = ["noise,no P"]  
# cases               = ["20240622D"] 
# nR                  = [1]

sweeps              = 6
startstate          = -1
mbiasT1 = zeros(length(cases),nrSegments)
mbiasT2 = zeros(length(cases),nrSegments)
mT2     = zeros(length(cases),nrSegments)

lines_color_cycle = [p["color"] for p in plt.rcParams["axes.prop_cycle"]]
(figd,axd)=subplots(1,figsize=(18,18))

# MRSTATToolbox can use options loaded from file. 
#    Oscar set them to something that looked useful for pure simulation stuff but please double-check
options = load_options_from_file("/home/mfuderer/mrstat_toolbox_based/scripts/mrstat_options_in_silico.toml")      

for (caseIndex,case) in enumerate(cases)
    for r in 1:nR[caseIndex]
        recon_options["rfFile"]  = nR[caseIndex]==1 ? case : case*"($r)"
        recon_options["nTR"]      = nky*sweeps
        recon_options["startstate"] = startstate

        sequence, coordinates, coilmaps, trajectory, mask, phantom = load_data_phantom(recon_options);
        # @show sequence.sliceprofiles 
        # ρ = complex.(simRho)
        # ρ = eltype((gpu(f32(sequence))).RF_train).(ρ)
        # parameters = collect(vec(phantom));

        # Rename sim{T1,T2,B1} to {T1,T2,B1} and simRho to {PDx,{Dy} to be able ot use @parameters from BlochSimulators
        T1, T2, B1 = simT1, simT2, simB1
        PDx, PDy = real(simRho), imag(simRho)

        # @parameters T1 T2 B1 PDx PDy creates a "StructArray of T₁T₂B₁xy's"
        parameters_with_B1 = @parameters T1 T2 B1 PDx PDy

        #parameters_with_B1 = [T₁T₂B₁xy(simT1[i],simT2[i], simB1[i], coordinates[i][1], coordinates[i][2]) for i in eachindex(parameters)]
        recon_options["simulation_parameters"] = T₁T₂B₁ρˣρʸ

        # Set all the things to single precision
        sequence = f32(sequence)
        trajectory = f32(trajectory)
        coilmaps = f32(reshape(only.(coilmaps), length(coilmaps),1))
        trajectory = f32(trajectory)
        parameters_with_B1 = f32(StructVector(parameters_with_B1))
        coordinates = StructVector(f32(coordinates))

        # Rather than generating echos, applying phase encoding and then calling the Mv function, we can directly call simulate_signal from BlochSimulators. 
        # Running this on the CPU (multi-threaded) for now since it doesn't take long anyway. 
        # For 2D experiments it's a different story.
        raw_data = simulate_signal(CPUThreads(), sequence, parameters_with_B1, trajectory, coordinates, coilmaps)
       
        # All arguments should be of the same floating point precision, let's just do Float32 using BlochSimulators.f32's function        
        # The arrays also need to have a specific number of dimensions, add missing dimensions with size 1
        # For raw data: get data back to CPU, add "locations" and "repetitions" dimensions and convert to Float32
        raw_data = reshape(raw_data, size(raw_data)..., 1, 1)
        
        # For coordinates: Store as StructArray{<:Coordinates}, add "x", "z" and "locations" dimensions
        coordinates = reshape(coordinates, 1, length(coordinates), 1, 1)
        
        # For coil sensitivity maps: Add "x", "z" and "locations" dimensions
        @assert size(coilmaps, 2) == 1
        coil_sensitivities = reshape(coilmaps, 1, length(coilmaps), 1, 1, 1)
 
        # For transmit field: Add "x", "z" and "locations" dimensions
        transmit_field = reshape(complex.(parameters_with_B1.B₁), 1, length(coordinates), 1, 1)
 

      
        recon_options["simulation_parameters"] = T₁T₂ρˣρʸ
 
        # Call the MRSTAT reconstruction function
        # Note that this should be run on a machine with GPU 
        ctx = MRSTATToolbox.MRSTAT.mrstat_recon_in_silico(sequence, trajectory, raw_data, coordinates, coil_sensitivities, transmit_field, options);
 
        # Extract the reconstructed T₁ and T₂ maps from the returned ctx object
        recon_res = (
            # ctx.reconstructed.T₁ has multiple named dimensions and resides on the 
            # with parent we get rid of the dimension names, with collect we get it back to 
            # the cpu and with vec we lose the dimensions
            T₁ = ctx.reconstructed.T₁ |> parent |> collect |> vec,
            T₂ = ctx.reconstructed.T₂ |> parent |> collect |> vec
        )

        rT1 = reshape(recon_res.T₁, repfac, nrSegments)
        rT2 = reshape(recon_res.T₂, repfac, nrSegments)
        sT1 = reshape(simT1, repfac, nrSegments)
        sT2 = reshape(simT2, repfac, nrSegments)
        sB1 = reshape(simB1, repfac, nrSegments)

        mbiasT1[caseIndex,:] = mean(sT1.-rT1, dims=1) |> vec
        mbiasT2[caseIndex,:] = mean(sT2.-rT2, dims=1) |> vec
        mT2[caseIndex,:]     = mean(  sT2,    dims=1) |> vec

        sVar = copy(sT1)
        if recon_options["simulationVariable"]=="T1"; sVar = sT1;
        elseif recon_options["simulationVariable"]=="T2"; sVar = sT2;
        elseif recon_options["simulationVariable"]=="B1"; sVar = sB1;
        elseif recon_options["simulationVariable"]=="measured from phantom"
            from_measured =  measuredS[caseIndex]*sB1[1]/recon_options["TR"]*(sT2[1]*(sT2[1]+0.12))
            sVar .= from_measured;
        else @assert false
        end

        centerRange=nky÷2-50 : nky÷2+50
        color = lines_color_cycle[caseIndex]
        #data = rT2[centerRange] .- sT2[centerRange]   
        data = rT1[centerRange] .- sT1[centerRange]   
        label = description[caseIndex]
        @show label, r, data[1]   
        # If r equals 1, add a label to the plot
        if r == 1
            axd.plot(sVar[centerRange], data, color=color, label=label)
        else
            axd.plot(sVar[centerRange], data, color=color)
        end
        axd.text(sVar[centerRange][1], data[1], string(r), color=color)

    end
end
axd.set_xlabel("value of $(recon_options["simulationVariable"])")
axd.set_ylabel("bias on T1 [s]")
axd.legend()
txtt1 = "T1=$(recon_options["simulationT1center"])s, "
txtt2 = "T2=$(recon_options["simulationT2center"])s, "
txtB1 = "B1=$(recon_options["simulationB1center"])"
if recon_options["simulationVariable"]=="T1"; txtt1="T1=variable, ";
elseif recon_options["simulationVariable"]=="T2"; txtt2="T2=variable, ";
elseif recon_options["simulationVariable"]=="B1"; txtB1="B1=variable";
elseif recon_options["simulationVariable"]=="measured from phantom"
    ; # no overwrite of texts
else @assert false
end
axd.text(0.2,0.9,txtt1*txtt2*txtB1, transform=axd.transAxes)

if recon_options["simulationVariable"]=="measured from phantom"
    axd.plot([0.0,0.02],[0.0,0.02],color="black")
end





## 2024-12-16 As above, but on cleanup, and aligning with one-curve-per-category
#      And then tuned to publication-style
function sawtooth(segs, center, spread, useLog=true)
    saw = zeros(segs)
    qs = segs÷4
    saw[1:qs]      = spread .* collect(range(start=0, stop=-1, length=qs))
    saw[qs+1:3*qs] = spread .* collect(range(start=-1, stop=1, length=2*qs))
    saw[3*qs+1:4*qs]=spread .* collect(range(start=1, stop=0, length=qs))
    if useLog
        saw = center .* exp.(saw)
    else
        saw = center .* max.((saw.+1.0),0.0)
    end
    return saw
end

include("../startup.jl")
include("setup.jl")
include("WrecSimulRun.jl")
include("../numerical_phantom/load_data_phantom.jl");
include("../numerical_phantom/RF_Shapes.jl");
PyPlot.rc("font", family="serif")
PyPlot.rc("font", size=14)

resource = has_cuda_gpu() ? CUDALibs() : CPU1()
recon_options = load_default_recon_options();

recon_options["recon_folder"] = "tmp";
recon_options["recon_subfolder"] = "tmp";
recon_options["numphantom"] = true;
recon_options["numphantom_rf_shape"] = "from_file" 

nky = 224
recon_options["objectSegs"] = nky
recon_options["maxRho"]   = 1.0
recon_options["simulationT1center"]  = 0.7 # 1.3
recon_options["simulationT2center"]  = 0.07 # 0.2
recon_options["simulationB1center"]  = 1.0
crit_k                                =  0.0 
recon_options["simulationVariable"] = "B1" # "TR/TD" # "measured from phantom"
recon_options["simulationSpread"] = 0.3 # used 0.8 for T1 and T2, 1.3 for δ # 0.3 for B1
recon_options["RhoVariation"]   = 0.0 

recon_options["numphantom_type"] = "line" 
recon_options["numphantom_size"] = (1,nky)
recon_options["numphantom_sequence"] = "Spoiled" 
recon_options["numphantom_trajectory"] = "Cartesian" 
recon_options["numphantom_noise"] = false
recon_options["simulation_parameters"] = T₁T₂B₁ρˣρʸ
recon_options["reconstruction_parameters"] = T₁T₂ρˣρʸ

recon_options["slice"] = 1;
recon_options["coils"] = 1; # should be a range
recon_options["maxstate"] = 64; 
recon_options["lsqr_its"] = 10;
recon_options["trf_max_iter_steihaug"] = 30;
recon_options["trf_max_iter"] = 20;
recon_options["slice_discretization"] = 1
recon_options["slice_profile_correction"] = "shinnar_leroux" # small_tip_angle or shinnar_leroux
recon_options["slice_thickness_multiplier"] = 1 # compute slice profiles from 0 to multiplier * nominal slice thickness

recon_options["scaling_factor"] = 1.0;         

#adpt(x) = MRSTAT.Reconstruction.adapt_to(resource, x)
noplot(x; figtitle="") = println("no plotting")

rng = MersenneTwister(2)

nrSegments = recon_options["objectSegs"]
spread = recon_options["simulationSpread"]
rhoVar = recon_options["RhoVariation"]
segsT1 = recon_options["simulationT1center"] .* ones(nrSegments)
segsT2 = recon_options["simulationT2center"] .* ones(nrSegments)
segsB1 = recon_options["simulationB1center"] .* ones(nrSegments)
if recon_options["simulationVariable"]=="T1"
    segsT1 = sawtooth(nrSegments, recon_options["simulationT1center"], spread)
elseif recon_options["simulationVariable"]=="T2"
    segsT2 = sawtooth(nrSegments, recon_options["simulationT2center"], spread)
elseif recon_options["simulationVariable"]=="B1"
    segsB1  = sawtooth(nrSegments, recon_options["simulationB1center"], spread, false)
elseif recon_options["simulationVariable"]=="measured from phantom";
    ; # no overwrites
else @assert false
end

segsRho = [recon_options["maxRho"]*exp(im*2*pi*crit_k *i/nrSegments) for i in 1:nrSegments]
segsMask = ones(nrSegments)
segsRho .*= segsMask
(xl,yl) = recon_options["numphantom_size"]
repfac = Int64(round(yl/nrSegments))

simRho = repeat(segsRho, inner=repfac)
simT1  = repeat(segsT1,  inner=repfac)
simT2  = repeat(segsT2,  inner=repfac)
simB1  = repeat(segsB1,  inner=repfac)
simMask =repeat(segsMask,inner=repfac)
B₁map = ones(yl)

description         = ["noise-optimized, no phase",    
                                        "B1-optimized,no phase",    
                                                          "noise-optimized, with phase",     
                                                                             "B1-optimized, with phase"]  
cases               = ["20240702V(5)",   "20240703W(5)",  "20240701S(5)",    "20240703X(3)"]
nR                  = [1,                1,               1,                  1]
# cases               = ["20240702V"   ,  "20240703W"   ,  "20240701S",       "20240703X"]
# nR                  = [10,              10,              10,                 10] 

sweeps              = 6
startstate          = -1
mbiasT1 = zeros(length(cases),nrSegments)
mbiasT2 = zeros(length(cases),nrSegments)
mT2     = zeros(length(cases),nrSegments)

lines_color_cycle = [p["color"] for p in plt.rcParams["axes.prop_cycle"]]
(figd,axd)=subplots(1,figsize=(8,5))

# MRSTATToolbox can use options loaded from file. 
#    Oscar set them to something that looked useful for pure simulation stuff but please double-check
options = load_options_from_file(pwd()*"/scripts/mrstat_options_in_silico.toml")      

slopes = zeros(length(cases))
for (caseIndex,case) in enumerate(cases)
    for r in 1:nR[caseIndex]
        recon_options["rfFile"]  = nR[caseIndex]==1 ? case : case*"($r)"
        recon_options["nTR"]      = nky*sweeps
        recon_options["startstate"] = startstate

        sequence, coordinates, coilmaps, trajectory, mask, phantom = load_data_phantom(recon_options);

        # Rename sim{T1,T2,B1} to {T1,T2,B1} and simRho to {PDx,{Dy} to be able ot use @parameters from BlochSimulators
        T1, T2, B1 = simT1, simT2, simB1
        PDx, PDy = real(simRho), imag(simRho)
        parameters_with_B1 = @parameters T1 T2 B1 PDx PDy
        recon_options["simulation_parameters"] = T₁T₂B₁ρˣρʸ

        # Set all the things to single precision
        sequence = f32(sequence)
        trajectory = f32(trajectory)
        coilmaps = f32(reshape(only.(coilmaps), length(coilmaps),1))
        trajectory = f32(trajectory)
        parameters_with_B1 = f32(StructVector(parameters_with_B1))
        coordinates = StructVector(f32(coordinates))

        # Rather than generating echos, applying phase encoding and then calling the Mv function, we can directly call simulate_signal from BlochSimulators. 
        # Running this on the CPU (multi-threaded) for now since it doesn't take long anyway. 
        # For 2D experiments it's a different story.
        raw_data = simulate_signal(CPUThreads(), sequence, parameters_with_B1, trajectory, coordinates, coilmaps)
       
        # All arguments should be of the same floating point precision, let's just do Float32 using BlochSimulators.f32's function        
        # The arrays also need to have a specific number of dimensions, add missing dimensions with size 1
        # For raw data: get data back to CPU, add "locations" and "repetitions" dimensions and convert to Float32
        raw_data = reshape(raw_data, size(raw_data)..., 1, 1)
        
        # For coordinates: Store as StructArray{<:Coordinates}, add "x", "z" and "locations" dimensions
        coordinates = reshape(coordinates, 1, length(coordinates), 1, 1)
        
        # For coil sensitivity maps: Add "x", "z" and "locations" dimensions
        @assert size(coilmaps, 2) == 1
        coil_sensitivities = reshape(coilmaps, 1, length(coilmaps), 1, 1, 1)
 
        # For transmit field: Add "x", "z" and "locations" dimensions
        transmit_field = reshape(complex.(parameters_with_B1.B₁), 1, length(coordinates), 1, 1)
 
        recon_options["simulation_parameters"] = T₁T₂ρˣρʸ
 
        # Call the MRSTAT reconstruction function
        # Note that this should be run on a machine with GPU 
        ctx = MRSTATToolbox.MRSTAT.mrstat_recon_in_silico(sequence, trajectory, raw_data, coordinates, coil_sensitivities, transmit_field, options);
 
        # Extract the reconstructed T₁ and T₂ maps from the returned ctx object
        recon_res = (
            # ctx.reconstructed.T₁ has multiple named dimensions and resides on the 
            # with parent we get rid of the dimension names, with collect we get it back to 
            # the cpu and with vec we lose the dimensions
            T₁ = ctx.reconstructed.T₁ |> parent |> collect |> vec,
            T₂ = ctx.reconstructed.T₂ |> parent |> collect |> vec
        )

        rT1 = reshape(recon_res.T₁, repfac, nrSegments)
        rT2 = reshape(recon_res.T₂, repfac, nrSegments)
        sT1 = reshape(simT1, repfac, nrSegments)
        sT2 = reshape(simT2, repfac, nrSegments)
        sB1 = reshape(simB1, repfac, nrSegments)

        mbiasT1[caseIndex,:] = mean(sT1.-rT1, dims=1) |> vec
        mbiasT2[caseIndex,:] = mean(sT2.-rT2, dims=1) |> vec
        mT2[caseIndex,:]     = mean(  sT2,    dims=1) |> vec

        sVar = copy(sT1)
        if recon_options["simulationVariable"]=="T1"; sVar = sT1;
        elseif recon_options["simulationVariable"]=="T2"; sVar = sT2;
        elseif recon_options["simulationVariable"]=="B1"; sVar = sB1;
        elseif recon_options["simulationVariable"]=="measured from phantom"
            from_measured =  measuredS[caseIndex]*sB1[1]/recon_options["TR"]*(sT2[1]*(sT2[1]+0.12))
            sVar .= from_measured;
        else @assert false
        end

        centerRange=nky÷2-50 : nky÷2+50
        color = lines_color_cycle[caseIndex]
        data = rT2[centerRange] .- sT2[centerRange] 
        xcoord = sVar[centerRange]  
        # data = rT1[centerRange] .- sT1[centerRange]   
        label = description[caseIndex]
        @show label, r, data[1]   
        # If r equals 1, add a label to the plot
        if r == 1
            axd.plot(sVar[centerRange], data, color=color, label=label)
        else
            axd.plot(sVar[centerRange], data, color=color)
        end
        if (nR[caseIndex]>1); axd.text(sVar[centerRange][1], data[1], string(r), color=color); end;
        slopes[caseIndex] = (data[51+10]-data[51-10])/(xcoord[51+10]-xcoord[51-10])
    end
end
axd.set_xlabel("value of $(recon_options["simulationVariable"])")
axd.set_ylabel("bias on T2 [s]")
axd.legend()
txtt1 = "T1=$(recon_options["simulationT1center"])s, "
txtt2 = "T2=$(recon_options["simulationT2center"])s, "
txtB1 = "B1=$(recon_options["simulationB1center"])"
if recon_options["simulationVariable"]=="T1"; txtt1="T1=variable, ";
elseif recon_options["simulationVariable"]=="T2"; txtt2="T2=variable, ";
elseif recon_options["simulationVariable"]=="B1"; txtB1="B1=variable";
elseif recon_options["simulationVariable"]=="measured from phantom"
    ; # no overwrite of texts
else @assert false
end
# axd.text(0.2,0.9,txtt1*txtt2*txtB1, transform=axd.transAxes) # In publication, this is for the legend

if recon_options["simulationVariable"]=="measured from phantom"
    axd.plot([0.0,0.02],[0.0,0.02],color="black")
end
@show slopes




## 2024-12-16 Recap on phantom scan analysis
# Although the scanning was 2024-07-10 and the reporting on 2024-07-23, here I re-use 
# "2024-08-12 Phantom analysis again, but try with diffusion-correction 
# (more or less copy-pasted from 2024-07-16, which was an adapted re use of script dd. 2024-05-06)"
# And assume that the graphs with diffusion-correction are easily back-adaptable to no-diff-correction
#
#  FAIL due to incompatible old data structures - load() cannot handle these 
#              
using NIfTI
include("figuresB1phantom.jl")
include("scanAnalysisB1Brain.jl")
folderDetails       = ["_nn","_nb", "_an", "_ab"]    

figurePars = Dict()
figurePars["folderDetails"] = folderDetails
figurePars["seqDescription"] = [ "No phase", "No phase, B1-opt", "Phase", "Phase, B1-opt"]
figurePars["recDescription"] = ["Pre-calibrated", "Mis-calibrated", "Non-calibrated"]
figurePars["ntypes"]        = [3,3,3,3]
figurePars["nRecons"]       = 1
figurePars["maxIt"]         = 21
figurePars["comparisonSet"] = [1,2]
figurePars["sliceRange"]    = 1:20 
figurePars["gels"]          = 1:12

scandata_folder = "/smb/user/mfuderer/DS-Data/Radiotherapie/Research/Project/MRSTAT/experiments/miha/Scandata_miha"
fn_common_set = [
    scandata_folder*"/20_198250c/mrstat",
    scandata_folder*"/20_198250b/mrstat",
    scandata_folder*"/20_198250a/mrstat"
        ]
description = ["Regular recon","B1 map modified 5%","Not B1 corrected"]
figurePars["fn_common_set"] = fn_common_set
figurePars["dispMax"]       = [2.0,0.5,1.0]
figurePars["diffuCorrFile"] = "/home/mfuderer/ownCloud - Fuderer, M. (Miha)@surfdrive.surf.nl/data/"*
                                  "diffusionAnalysis/mapCol240812A.jld2"

figuresReadData!(figurePars)

meanoverdyn = figurePars["meanoverdyn"]   
tubes       = figurePars["tubes"]
usableSliceRange = figurePars["usableSliceRange"] 
 

figuresPhantomFig1(figurePars)
figuresPhantomFig2plus(figurePars, false);
figuresPhantomFig2plus(figurePars, true); # with diffusion correction
figureAllIm(figurePars)
figureDifferences(figurePars)

# visualise bias
tubes           = figurePars["tubes"]
goldstandard_3T = figurePars["goldstandard_3T"]
meanMeans       = figurePars["meanMeans"] 
tubeLabel       = figurePars["tubeLabel"] 
gels            = figurePars["gels"]
testIt          = figurePars["testIt"]

lines_color_cycle = [p["color"] for p in plt.rcParams["axes.prop_cycle"]]


if size(meanMeans)[1]>1
    comparisonSet = [1,2]
    (fig, ax)   =(subplots(1,2,figsize=(12, 6))) 
    fig.suptitle("Bias difference")
    for m in 1:2
        gt = goldstandard_3T[m]
        xxx = (0.001 .* [gt[tubeLabel[gel]] for gel in gels])
        for case in eachindex(folderDetails)
            label = chop(folderDetails[case],head=1,tail=0)
            color = lines_color_cycle[case]
            yyy = meanMeans[comparisonSet[2],case,m,gels] .-meanMeans[comparisonSet[1],case,m,gels]
            ax[m].scatter(xxx,yyy,label=label, color=color)
            for g in gels; ax[m].text(xxx[g],yyy[g],"$g"); end
            slope = mean(yyy) / mean(xxx)
            xl = minimum(xxx); xh = maximum(xxx)
            # ax[m].plot([xl,xh],slope.*[xl,xh], color=color)
        end
        ax[m].set_xlabel("Goldstandard T$m", fontsize=18)
        ax[m].set_ylabel(description[comparisonSet[2]]*" minus "*description[comparisonSet[1]], fontsize=12)
        ax[m].legend()
    end
end

# for sss in usableSliceRange
#     thisT1 = meanoverdyn[1][1,sss,1,testIt[1,1],:,:]
#     #ShowTubes(thisT1, tubes)
#     for (i,tube) in enumerate(tubes)
#         @show i, mean(thisT1[tube])
#     end
# end
thisT1 = meanoverdyn[1][1,1:20,1,testIt[1,1],:,:]
tube=tubes[7]
@show mean(thisT1[10:10,tube])

recType = 1; case=1; indexRange=1:20; m=1
ttt = meanoverdyn[recType][case,indexRange,m,testIt[recType,case],:,:] 
@show mean(ttt[10:10,tube])



## 2024-12-18 recap on sequence generation
#  Copied from "2024-06-29 Similar script as the set used 2024-06-18 and on, 
#                       but used mainly to experiment with optimizer settings" 
#  (Although the actual re-use of the copied part is likely from 2024-07-03)
# further refactored to semi-automate the set of four sequences

case = 2 # 1 or 2, 3, 4;  to be cycled manually
caseName = ["NoPhase_noise", "NoPhase_B1opt", "Phase_noise", "Phase_B1opt"]
b1handling = ["no",          "sensitivity",   "no",          "sensitivity"]
qPhase    = [false,          false,           true,          true]

include("setup.jl")
recon_options = Dict() # erase all existing settings
nsweeps = 6                                               
nky = 224                                                 
nTR = round(Int64, nsweeps*nky)
ky = 1.0 .*(repeat(1:nky, inner=1, outer=nsweeps)); 
kz = ones(nsweeps*nky)
trajectorySet = BLAKJac.TrajectorySet(ky,kz)
BLAKJac.BLAKJac_defaults!(trajectorySet, recon_options)
rfFunction = rfDictionary["from_file"]
saved_H = Dict()

recon_options["useSymmetry"] = true     
recon_options["TR"]      = 0.01
recon_options["startstate"] = -1 
recon_options["sigma_ref"] = 1.4 # See logbook 20220815
recon_options["optpars"]   = Optim.Options(time_limit = 20000.0, iterations = 100000, f_tol=1.0e-5, g_tol = 1.0e-5)  
# @warn "debugging" 
# recon_options["optpars"]   = Optim.Options(time_limit = 20.0, iterations = 100000, f_tol=1.0e-5, g_tol = 1.0e-5)  

recon_options["opt_criterion"] = "noise_level" 
recon_options["account_SAR"]   = true     

recon_options["sar_limit"] = 40^2/0.01 
recon_options["emphasize_low_freq"] = true 
recon_options["handleB1"] = b1handling[case] # "no" # "sensitivity" # "no" # "sensitivity" #
recon_options["lambda_B1"] = 10.0     
recon_options["opt_initialize"] = "cRandom30" 
recon_options["opt_focus"] = "max"      
recon_options["opt_complex"] = false      
recon_options["opt_account_maxFlip"] = false
recon_options["opt_keep_positive"] = false                           
recon_options["opt_slow_phase"] = qPhase[case] # false # true                         
recon_options["considerCyclic"] = false  
recon_options["opt_emergeCriterion"] = 500 # 2000 # 500 # 2000
ph = [] 
# ph = zeros(nTR); ph .= 2.0;
recon_options["opt_imposed_2nd_derivative_of_phase"] = ph
recon_options["opt_iterations_limit"] = 1
recon_options["sizeSteps"] = [6]  
recon_options["B1metric"] = "multi_point_values" # "multi_point"         
nRealizations = 10   
recon_options["rfFolder"]= "./RFsequences/"    

fn_base = caseName[case]
for i in 1:nRealizations; goodseed = i
    stageText = ""
    portionRange = 0:0
    fn = recon_options["rfFolder"]*"$fn_base($i).jld2"
    RFdeg = BLAKJac.BLAKJac_optimize(trajectorySet, recon_options, goodseed);
    FileIO.save(fn,"RFdeg",RFdeg)
    @show fn
end 

#
@show recon_options["T1T2set"]
include("BLAKJac_B1_figures.jl")
testCase = caseName[case];   Nr=10
map_B1_sensitivities(testCase,5)
@show recon_options["T1T2set"]

recon_options["handleB1"] = "sensitivity" 
recon_options["B1metric"] = "multi_point_values"   
winner=0; optscore = Inf       
figure()
for rrr in 1:Nr
    fn = "$testCase($rrr)"
    recon_options["rfFile"]  = fn
    RFdeg = rfFunction(recon_options["nTR"], recon_options["nky"])
    noises, ItotAll, b1f = BLAKJac.BLAKJac_analysis!(cpu, RFdeg, trajectorySet, recon_options, saved_H)
    mn = maximum(noises[2:3]); b1m=mean(b1f); b1max = maximum(b1f)
    mixCrit = sqrt(mn^2+(10*b1max)^2)
    @printf("Try %d: n=%.2f, T1B1=%.3f, T2B1=%.3f, criterium=%.2f \n", rrr, mn, b1f[2], b1f[3], mixCrit)
    if mixCrit < optscore
        optscore = mixCrit
        winner = rrr
    end
    scatter(mn,rrr, color="blue")   
    scatter(mixCrit,rrr, color="red")
    scatter(10*b1f[3],rrr, color="green")
end
scatter(optscore, winner, color="red", s=100)
@printf("Ant the winning sequence is ... %d \n", winner)




